{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "eddf6f7b-7c6f-4500-9ccf-5a791e0f6c10",
   "metadata": {},
   "outputs": [],
   "source": [
    "using LinearAlgebra, SparseArrays, Printf, DelimitedFiles, Statistics\n",
    "using Plots\n",
    "import XLSX\n",
    "\n",
    "# -----------------------\n",
    "# Constants\n",
    "# -----------------------\n",
    "const F  = 96485.3329\n",
    "const Rg = 8.314462618\n",
    "const atm = 101325.0\n",
    "\n",
    "# -----------------------\n",
    "# Membrane and operating conditions (PEM electrolyzer orientation)\n",
    "# -----------------------\n",
    "const Lm   = 25e-6          # membrane thickness [m]\n",
    "const T    = 353.15         # K\n",
    "const RH   = 1.0            # 0..1\n",
    "const n_drag = 2.5\n",
    "const cH2O_eff = 5.55e4     # mol/m^3\n",
    "const use_drag = false\n",
    "\n",
    "# Cathode produces H2; Anode produces O2\n",
    "pH2_ca(t) = 1.0*atm         # hydrogen partial pressure at cathode side\n",
    "pH2_an(t) = 0.0\n",
    "pO2_an(t) = 1.0*atm         # oxygen partial pressure at anode side\n",
    "pO2_ca(t) = 0.0\n",
    "\n",
    "# Applied current density for electro-osmotic drift (optional)\n",
    "i_app(t)  = 0.0             # A/m^2\n",
    "v_d(t)    = use_drag ? (n_drag * i_app(t) / F) / cH2O_eff : 0.0  # m/s anode→cathode\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "# -----------------------\n",
    "# Transport properties, Arrhenius + simple RH hooks\n",
    "# -----------------------\n",
    "const Tref_P  = 353.15      # K, permeability ref\n",
    "const Tref_D  = 293.15      # K, diffusivity ref\n",
    "\n",
    "# O2 in ionomer (representative, consistent with Nafion-class data)\n",
    "const D_ref_O2 = 2.23e-12\n",
    "const P_ref_O2_Pa  = 1.6e-14\n",
    "const Ea_D_O2 = 12.6e3\n",
    "const Ea_P_O2 = 23e3\n",
    "scale_D_O2_RH(rh) = 0.6 + 0.4*clamp(rh,0,1)\n",
    "scale_H_O2_RH(rh) = 1.2 - 0.2*clamp(rh,0,1)\n",
    "\n",
    "# H2 in ionomer (representative for PFSA)\n",
    "const D_ref_H2 = 1.0e-11\n",
    "const P_ref_H2_Pa  = 3.85e-14\n",
    "const Ea_D_H2 = 10e3\n",
    "const Ea_P_H2 = 27e3\n",
    "scale_D_H2_RH(rh) = 0.6 + 0.4*clamp(rh,0,1)\n",
    "scale_H_H2_RH(rh) = 1.2 - 0.2*clamp(rh,0,1)\n",
    "\n",
    "@inline arrhenius(xref, Ea, T, Tref) = xref * exp(-(Ea/Rg) * (1/T - 1/Tref))\n",
    "\n",
    "# Build D(T,RH), H(T,RH), P = D*H\n",
    "function props_O2(T, RH)\n",
    "    D = arrhenius(D_ref_O2, Ea_D_O2, T, Tref_D) * scale_D_O2_RH(RH)\n",
    "    P = arrhenius(P_ref_O2_Pa, Ea_P_O2, T, Tref_P)\n",
    "    H = P / D * scale_H_O2_RH(RH)\n",
    "    return D, H, P\n",
    "end\n",
    "function props_H2(T, RH)\n",
    "    D = arrhenius(D_ref_H2, Ea_D_H2, T, Tref_D) * scale_D_H2_RH(RH)\n",
    "    P = arrhenius(P_ref_H2_Pa, Ea_P_H2, T, Tref_P)\n",
    "    H = P / D * scale_H_H2_RH(RH)\n",
    "    return D, H, P\n",
    "end\n",
    "\n",
    "# -----------------------\n",
    "# Mesh and helpers\n",
    "# -----------------------\n",
    "struct Mesh1D\n",
    "    x::Vector{Float64}\n",
    "    h::Float64\n",
    "    N::Int\n",
    "end\n",
    "function line_mesh(L, Ne::Int)\n",
    "    x = collect(range(0.0, L; length=Ne+1))\n",
    "    Mesh1D(x, L/Ne, Ne+1)\n",
    "end\n",
    "\n",
    "function mass_lumped(m::Mesh1D)\n",
    "    d = fill(m.h, m.N); d[1] = m.h/2; d[end] = m.h/2\n",
    "    spdiagm(0 => d)\n",
    "end\n",
    "\n",
    "function diffusion_stiffness(m::Mesh1D, D::Float64)\n",
    "    Ke = (D/m.h) * [1.0 -1.0; -1.0 1.0]\n",
    "    K = spzeros(m.N, m.N)\n",
    "    for e in 1:m.N-1\n",
    "        n1, n2 = e, e+1\n",
    "        @inbounds begin\n",
    "            K[n1,n1] += Ke[1,1]; K[n1,n2] += Ke[1,2]\n",
    "            K[n2,n1] += Ke[2,1]; K[n2,n2] += Ke[2,2]\n",
    "        end\n",
    "    end\n",
    "    K\n",
    "end\n",
    "\n",
    "# conservative upwind advection RHS for constant v\n",
    "function advective_rhs_upwind(m::Mesh1D, c::Vector{Float64}, v::Float64, cL_face::Float64, cR_face::Float64)\n",
    "    F = similar(c, m.N+1)\n",
    "    F[1] = v ≥ 0 ? v*cL_face : v*c[1]\n",
    "    for j in 2:m.N\n",
    "        F[j] = v ≥ 0 ? v*c[j-1] : v*c[j]\n",
    "    end\n",
    "    F[m.N+1] = v ≥ 0 ? v*c[end] : v*cR_face\n",
    "    a = zeros(m.N)\n",
    "    a[1] = (F[2]-F[1])/m.h\n",
    "    for i in 2:m.N-1\n",
    "        a[i] = (F[i+1]-F[i])/m.h\n",
    "    end\n",
    "    a[end] = (F[m.N+1]-F[m.N])/m.h\n",
    "    return -a\n",
    "end\n",
    "\n",
    "# Robin BC assembly for implicit operator: add k at boundary nodes and k*c_sat to RHS\n",
    "function add_robin!(K::SparseMatrixCSC, rhs::Vector{Float64}; kL=0.0, c_sat_L=0.0, kR=0.0, c_sat_R=0.0, θ=1.0, c_prev_L=0.0, c_prev_R=0.0)\n",
    "    # θ-method splitting of linear term k c: θ*k to LHS; (1-θ)*k*c_prev to RHS\n",
    "    if kL != 0.0\n",
    "        K[1,1] += θ*kL\n",
    "        rhs[1] += (1-θ)*kL*c_prev_L + kL*c_sat_L\n",
    "    else\n",
    "        rhs[1] += 0.0\n",
    "    end\n",
    "    if kR != 0.0\n",
    "        K[end,end] += θ*kR\n",
    "        rhs[end] += (1-θ)*kR*c_prev_R + kR*c_sat_R\n",
    "    else\n",
    "        rhs[end] += 0.0\n",
    "    end\n",
    "end\n",
    "\n",
    "# one-sided boundary fluxes including advection\n",
    "function flux_at_faces(m::Mesh1D, c::Vector{Float64}, D::Float64, v::Float64, cL_face::Float64, cR_face::Float64)\n",
    "    dcL = (-3c[1] + 4c[2] - c[3]) / (2m.h)\n",
    "    dcR = ( 3c[end] - 4c[end-1] + c[end-2]) / (2m.h)\n",
    "    JL = -D*dcL + v*(v ≥ 0 ? cL_face : c[1])\n",
    "    JR = -D*dcR + v*(v ≥ 0 ? c[end]  : cR_face)\n",
    "    return JL, JR\n",
    "end\n",
    "\n",
    "# volumetric degassing sink S = k_deg * max(0, c - c_sat_bulk)\n",
    "function degassing_sink(c::Vector{Float64}, c_sat_bulk::Float64, k_deg::Float64)\n",
    "    if k_deg <= 0.0\n",
    "        return zeros(length(c))\n",
    "    end\n",
    "    @. k_deg * max(0.0, c - c_sat_bulk)\n",
    "end\n",
    "\n",
    "# one species implicit diffusion + Robin, explicit advection and degassing\n",
    "function step_species!(c::Vector{Float64}; m::Mesh1D, Δt, θ, D, v, cL_face, cR_face, M,\n",
    "                       kL, c_sat_L, kR, c_sat_R, k_deg, c_sat_bulk)\n",
    "\n",
    "    Kd = diffusion_stiffness(m, D)\n",
    "    LHS = (M/Δt) + θ*Kd\n",
    "    RHS = (M/Δt)*c - (1-θ)*Kd*c + advective_rhs_upwind(m, c, v, cL_face, cR_face)\n",
    "\n",
    "    # add Robin terms\n",
    "    add_robin!(LHS, RHS; kL=kL, c_sat_L=c_sat_L, kR=kR, c_sat_R=c_sat_R, θ=θ, c_prev_L=c[1], c_prev_R=c[end])\n",
    "\n",
    "    # explicit volumetric degassing sink\n",
    "    Sdeg = degassing_sink(c, c_sat_bulk, k_deg)\n",
    "    RHS .-= Sdeg\n",
    "\n",
    "    # solve\n",
    "    cnew = LHS \\ RHS\n",
    "    @inbounds for i in 1:m.N\n",
    "        cnew[i] = max(cnew[i], 0.0)\n",
    "    end\n",
    "    return cnew\n",
    "end\n",
    "\n",
    "\n",
    "\n",
    "function icross_theory(; P_H2, P_O2, L, dpH2=1.0*atm, dpO2=1.0*atm)\n",
    "    JH2 = P_H2*dpH2/L\n",
    "    JO2 = P_O2*dpO2/L\n",
    "    return 2F*JH2 + 4F*JO2   # A/m^2\n",
    "end\n",
    "\n",
    "\n",
    "# -----------------------\n",
    "# Runner\n",
    "# -----------------------\n",
    "function run_transient(; Ne=250, Δt=0.05, tF=30.0, θ=1.0, save_every=100,\n",
    "                        out_dir=\"out\", out_prefix=\"pem_xover\",\n",
    "                        # interfacial desorption mass-transfer coefficients [m/s]\n",
    "                        kH2_L=0.0, kH2_R=1e-4,   # H2 desorbs at cathode (right) in PEMWE\n",
    "                        kO2_L=1e-4, kO2_R=0.0,   # O2 desorbs at anode (left)\n",
    "                        # optional volumetric degassing inside membrane\n",
    "                        kdeg_H2=0.0, kdeg_O2=0.0)\n",
    "\n",
    "    mkpath(out_dir)\n",
    "    m = line_mesh(Lm, Ne)\n",
    "    M = mass_lumped(m)\n",
    "\n",
    "    D_O2, H_O2, P_O2 = props_O2(T, RH)\n",
    "    D_H2, H_H2, P_H2 = props_H2(T, RH)\n",
    "    # theory line using current props and actual Δp across the membrane\n",
    "    dpH2 = pH2_ca(0.0) - pH2_an(0.0)   # cathode − anode\n",
    "    dpO2 = pO2_an(0.0) - pO2_ca(0.0)   # anode − cathode\n",
    "    ith = icross_theory(P_H2=P_H2, P_O2=P_O2, L=Lm, dpH2=dpH2, dpO2=dpO2)\n",
    "\n",
    "\n",
    "    @printf \"Props @ T=%.1f K RH=%.0f%%\\n\" T RH*100\n",
    "    @printf \"O2: D=%.3e m^2/s  H=%.3e mol m^-3 Pa^-1  P=%.3e mol m^-1 s^-1 Pa^-1\\n\" D_O2 H_O2 P_O2\n",
    "    @printf \"H2: D=%.3e m^2/s  H=%.3e mol m^-3 Pa^-1  P=%.3e mol m^-1 s^-1 Pa^-1\\n\" D_H2 H_H2 P_H2\n",
    "\n",
    "    # state\n",
    "    cO2 = zeros(m.N)\n",
    "    cH2 = zeros(m.N)\n",
    "\n",
    "    # logs\n",
    "    times = Float64[]\n",
    "    JH2_L = Float64[]; JH2_R = Float64[]\n",
    "    JO2_L = Float64[]; JO2_R = Float64[]\n",
    "    i_cross = Float64[]\n",
    "    MB_resid = Float64[]      # mass balance residual [mol m^-2 s^-1], see below\n",
    "    snaps = Dict{Float64,Tuple{Vector{Float64},Vector{Float64}}}()\n",
    "\n",
    "    # helper for total storage [mol m^-2]\n",
    "    function storage(c)\n",
    "        # integral c dx via lumped mass diagonal\n",
    "        sum(diag(M) .* c)\n",
    "    end\n",
    "\n",
    "    t = 0.0\n",
    "    nsteps = Int(round(tF/Δt))\n",
    "    cO2_prev = copy(cO2)\n",
    "    cH2_prev = copy(cH2)\n",
    "\n",
    "    for k in 1:nsteps\n",
    "        t += Δt\n",
    "        vd = v_d(t)\n",
    "\n",
    "        # Henry solubilities at faces\n",
    "        cH2_L_face = H_H2 * pH2_an(t)  # left face (anode side) H2\n",
    "        cH2_R_face = H_H2 * pH2_ca(t)  # right face (cathode side) H2\n",
    "        cO2_L_face = H_O2 * pO2_an(t)  # left face (anode) O2\n",
    "        cO2_R_face = H_O2 * pO2_ca(t)  # right face (cathode) O2\n",
    "\n",
    "        # step each species\n",
    "        cH2 = step_species!(cH2; m, Δt, θ, D=D_H2, v=vd, cL_face=cH2_L_face, cR_face=cH2_R_face, M,\n",
    "                            kL=kH2_L, c_sat_L=cH2_L_face, kR=kH2_R, c_sat_R=cH2_R_face,\n",
    "                            k_deg=kdeg_H2, c_sat_bulk=cH2_R_face)   # H2 supersat w.r.t cathode gas\n",
    "        cO2 = step_species!(cO2; m, Δt, θ, D=D_O2, v=vd, cL_face=cO2_L_face, cR_face=cO2_R_face, M,\n",
    "                            kL=kO2_L, c_sat_L=cO2_L_face, kR=kO2_R, c_sat_R=cO2_R_face,\n",
    "                            k_deg=kdeg_O2, c_sat_bulk=cO2_L_face)   # O2 supersat w.r.t anode gas\n",
    "\n",
    "        # boundary fluxes (total: diffusion + advection) into +x\n",
    "        jL_H2, jR_H2 = flux_at_faces(m, cH2, D_H2, vd, cH2_L_face, cH2_R_face)\n",
    "        jL_O2, jR_O2 = flux_at_faces(m, cO2, D_O2, vd, cO2_L_face, cO2_R_face)\n",
    "\n",
    "        # crossover current density\n",
    "        # use the gas that reaches the opposite side\n",
    "        iH2 = 2*F * max(-jL_H2, 0.0)   # H2 exiting at anode (x=0)\n",
    "        iO2 = 4*F * max( jR_O2, 0.0)   # O2 exiting at cathode (x=L)\n",
    "        push!(i_cross, iH2 + iO2)\n",
    "\n",
    "\n",
    "        push!(times, t)\n",
    "        push!(JH2_L, jL_H2); push!(JH2_R, jR_H2)\n",
    "        push!(JO2_L, jL_O2); push!(JO2_R, jR_O2)\n",
    "\n",
    "        # mass balance residual check for both species combined:\n",
    "        # d/dt ∫(cH2+cO2)dx − [ (J_total_in at x=0) − (J_total_out at x=L) ] + sinks ≈ 0\n",
    "        # Here sinks are explicit volumetric degassing already subtracted in RHS, so we evaluate residual numerically\n",
    "        dM = (storage(cH2) - storage(cH2_prev) + storage(cO2) - storage(cO2_prev)) / Δt\n",
    "        netJ = (jL_H2 + jL_O2) - (jR_H2 + jR_O2)\n",
    "        push!(MB_resid, dM - netJ)\n",
    "        cH2_prev .= cH2; cO2_prev .= cO2\n",
    "\n",
    "        if k % save_every == 0 || k == nsteps\n",
    "            snaps[t] = (copy(cH2), copy(cO2))\n",
    "            @printf \"t=%.2f s  i_cross=%.3e A/m^2  |σ_H2,R=%.3f  σ_O2,L=%.3f|  MBres=%.2e\\n\" t (iH2+iO2) (maximum(cH2)/max(cH2_R_face,1e-30)) (maximum(cO2)/max(cO2_L_face,1e-30)) MB_resid[end]\n",
    "        end\n",
    "    end\n",
    "\n",
    "    # final snapshots and supersaturation profiles vs producer sides\n",
    "    tlast = maximum(keys(snaps))\n",
    "    cH2_last, cO2_last = snaps[tlast]\n",
    "    cH2_sat_R = H_H2 * pH2_ca(tlast) .+ 0.0\n",
    "    cO2_sat_L = H_O2 * pO2_an(tlast) .+ 0.0\n",
    "    σH2 = cH2_last ./ max(cH2_sat_R, 1e-30)\n",
    "    σO2 = cO2_last ./ max(cO2_sat_L, 1e-30)\n",
    "\n",
    "    # CSVs\n",
    "    open(joinpath(out_dir, \"$(out_prefix)_final_profile.csv\"),\"w\") do io\n",
    "        println(io, \"x,cH2,cO2\")\n",
    "        for i in 1:m.N\n",
    "            println(io, \"$(m.x[i]),$(cH2_last[i]),$(cO2_last[i])\")\n",
    "        end\n",
    "    end\n",
    "    open(joinpath(out_dir, \"$(out_prefix)_supersat_profile.csv\"),\"w\") do io\n",
    "        println(io, \"x,σH2_cathode,σO2_anode\")\n",
    "        for i in 1:m.N\n",
    "            println(io, \"$(m.x[i]),$(σH2[i]),$(σO2[i])\")\n",
    "        end\n",
    "    end\n",
    "    open(joinpath(out_dir, \"$(out_prefix)_flux_time.csv\"),\"w\") do io\n",
    "        println(io, \"t,JH2_L,JH2_R,JO2_L,JO2_R,i_cross,MB_resid\")\n",
    "        for i in 1:length(times)\n",
    "            println(io, \"$(times[i]),$(JH2_L[i]),$(JH2_R[i]),$(JO2_L[i]),$(JO2_R[i]),$(i_cross[i]),$(MB_resid[i])\")\n",
    "        end\n",
    "    end\n",
    "\n",
    "    # Excel workbook\n",
    "    XLSX.openxlsx(joinpath(out_dir, \"$(out_prefix).xlsx\"), mode=\"w\") do xf\n",
    "        sheet1 = XLSX.addsheet!(xf, \"final_profile\")\n",
    "        XLSX.writetable!(sheet1,\n",
    "                         (m.x, cH2_last, cO2_last),\n",
    "                         [\"x_m\",\"cH2\",\"cO2\"];\n",
    "                         anchor_cell = XLSX.CellRef(\"A1\"))\n",
    "\n",
    "        sheet2 = XLSX.addsheet!(xf, \"flux_time\")\n",
    "        XLSX.writetable!(sheet2,\n",
    "                         (times, JH2_L, JH2_R, JO2_L, JO2_R, i_cross, MB_resid),\n",
    "                         [\"t_s\",\"JH2_L\",\"JH2_R\",\"JO2_L\",\"JO2_R\",\"i_cross\",\"MB_resid\"];\n",
    "                         anchor_cell = XLSX.CellRef(\"A1\"))\n",
    "\n",
    "        sheet3 = XLSX.addsheet!(xf, \"supersaturation\")\n",
    "        XLSX.writetable!(sheet3,\n",
    "                         (m.x, σH2, σO2),\n",
    "                         [\"x_m\",\"sigma_H2_cathode\",\"sigma_O2_anode\"];\n",
    "                         anchor_cell = XLSX.CellRef(\"A1\"))\n",
    "    end\n",
    "\n",
    "    # Plots\n",
    "    p1 = plot(title=\"Dissolved gases across membrane at t=$(round(tlast,digits=2)) s\",\n",
    "              xlabel=\"x [μm]\", ylabel=\"c [mol m⁻³]\")\n",
    "    plot!(p1, m.x .* 1e6, cH2_last, label=\"H2\")\n",
    "    plot!(p1, m.x .* 1e6, cO2_last, label=\"O2\")\n",
    "    savefig(p1, joinpath(out_dir, \"$(out_prefix)_profiles.png\"))\n",
    "\n",
    "    p2 = plot(times, i_cross, xlabel=\"t [s]\", ylabel=\"i_cross [A m⁻²]\",\n",
    "              title=\"Crossover current density vs time\", label=\"i_cross\")\n",
    "    savefig(p2, joinpath(out_dir, \"$(out_prefix)_icross.png\"))\n",
    "\n",
    "    p3 = plot(title=\"Fluxes at faces\", xlabel=\"t [s]\", ylabel=\"Flux [mol m⁻² s⁻¹]\")\n",
    "    plot!(p3, times, JH2_R, label=\"H2 at cathode (+L)\")\n",
    "    plot!(p3, times, -JO2_L, label=\"O2 into anode (0)\")\n",
    "    savefig(p3, joinpath(out_dir, \"$(out_prefix)_fluxes.png\"))\n",
    "\n",
    "    p4 = plot(times, MB_resid, xlabel=\"t [s]\", ylabel=\"residual [mol m⁻² s⁻¹]\",\n",
    "              title=\"Mass balance residual (storage − net flux)\", label=\"residual\")\n",
    "    savefig(p4, joinpath(out_dir, \"$(out_prefix)_massbalance.png\"))\n",
    "\n",
    "    @info \"Wrote outputs to: $(abspath(out_dir))\"\n",
    "end\n",
    "\n",
    "# run\n",
    "run_transient()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Julia 1.11.6",
   "language": "julia",
   "name": "julia-1.11"
  },
  "language_info": {
   "file_extension": ".jl",
   "mimetype": "application/julia",
   "name": "julia",
   "version": "1.11.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
